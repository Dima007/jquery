/**
 * Special concat/build task to handle various jQuery build requirements
 * Concats AMD modules, removes their definitions, and includes/excludes specified modules
 */

module.exports = function( grunt ) {

	var rdefineEnd = /\}\);[^}\w]*$/,
		requirejs = require("./r"),
		config = {
			baseUrl: "src",
			name: "jquery",
			out: "dist/jquery.js",
			// We have multiple minify steps
			optimize: "none",
			skipSemiColonInsertion: true,
			wrap: {
				startFile: "src/intro.js",
				endFile: "src/outro.js"
			},
			onBuildWrite: convert
		};

	/**
	 * Convert "var" modules to var declarations
	 * "var module" means the module only contains a return statement that should be converted to a var declaration
	 * This is indicated by including the file in any "var" folder
	 * Strip all definitions generated by requirejs
	 * @param {String} output
	 */
	function convert( name, path, contents ) {
		// Convert var modules
		if ( /\/var\//.test( path ) ) {
			contents = contents
				.replace( /define\([\w\W]*?return/, "var " + (/var\/([\w-]+)/.exec(name)[1]) + " =" )
				.replace( rdefineEnd, "" );

		// Sizzle treatment
		} else if ( /\/sizzle$/.test( name ) ) {
			contents = "var Sizzle = " + contents
				// Remove EXPOSE lines from Sizzle
				.replace( /\/\/\s*EXPOSE[\w\W]*\/\/\s*EXPOSE/, "return Sizzle;" );

		} else {

			// Ignore jQuery's return statement (the only necessary one)
			if ( name !== "jquery" ) {
				contents = contents
					.replace( /return\s+[^\}]+(\}\);[^\w\}]*)$/, "$1" );
			}

			// Remove define wrappers, closure ends, and empty declarations
			contents = contents
				.replace( /define\([^{]*?{/, "" )
				.replace( rdefineEnd, "" )
				// Remove empty definitions
				.replace( /define\(\[[^\]]+\]\)[\W\n]+$/, "" );
		}
		return contents;
	}

	grunt.registerMultiTask(
		"build",
		"Concatenate source, remove sub AMD definitions, (include/exclude modules with +/- flags), embed date/version",
	function() {
		var flag,
			done = this.async(),
			compiled = "",
			flags = this.flags,
			optIn = !flags["*"],
			explicit = optIn || Object.keys(flags).length > 1,
			name = this.data.dest,
			src = this.data.src,
			minimum = this.data.minimum,
			deps = {},
			excluded = [],
			included = [],
			version = grunt.config( "pkg.version" ),
			excluder = function( flag ) {
				var m = /^(\+|\-|)(\w+)$/.exec( flag ),
					exclude = m[1] === "-",
					module = m[2];

				// Can't exclude certain modules
				if ( exclude ) {
					if ( minimum.indexOf( module ) === -1 ) {
						excluded.push( module );
					} else {
						grunt.log.error( "Module \"" + module + "\" is a mimimum requirement.");
					}
				} else {
					included.push( module );
				}
			};

		// append commit id to version
		if ( process.env.COMMIT ) {
			version += " " + process.env.COMMIT;
		}

		// figure out which files to exclude based on these rules in this order:
		//  dependency explicit exclude
		//  > explicit exclude
		//  > explicit include
		//  > dependency implicit exclude
		//  > implicit exclude
		// examples:
		//  *                  none (implicit exclude)
		//  *:*                all (implicit include)
		//  *:*:-css           all except css and dependents (explicit > implicit)
		//  *:*:-css:+effects  same (excludes effects because explicit include is trumped by explicit exclude of dependency)
		//  *:+effects         none except effects and its dependencies (explicit include trumps implicit exclude of dependency)
		for ( flag in flags ) {
			if ( flag !== "*" ) {
				excluder( flag );
			}
		}
		grunt.verbose.writeflags( excluded, "Excluded" );
		grunt.verbose.writeflags( included, "Included" );

		// append excluded modules to version
		if ( excluded.length ) {
			version += " -" + excluded.join( ",-" );
			// set pkg.version to version with excludes, so minified file picks it up
			grunt.config.set( "pkg.version", version );
			grunt.verbose.writeln( "Version changed to " + version );
			config.include = included;
			config.exclude = excluded;
		}

		/**
		 * Handle Final output from the optimizer
		 * @param {String} output
		 */
		config.out = function( compiled ) {
			compiled = compiled
				// Embed Version
				.replace( /@VERSION/g, version )
				// Embed Date
				// yyyy-mm-ddThh:mmZ
				.replace( /@DATE/g, ( new Date() ).toISOString().replace( /:\d+\.\d+Z$/, "Z" ) );

			// Write concatenated source to file
			grunt.file.write( name, compiled );
		};

		// Trace dependencies and concatenate files
		requirejs.optimize( config, function( response ) {
			grunt.log.writeln( response );
			grunt.log.ok( "File '" + name + "' created." );
			done();
		}, function( err ) {
			done( err );
		});
	});

	// Special "alias" task to make custom build creation less grawlix-y
	grunt.registerTask( "custom", function() {
		var done = this.async(),
			args = [].slice.call(arguments),
			modules = args.length ? args[0].replace(/,/g, ":") : "";


		// Translation example
		//
		//   grunt custom:+ajax,-dimensions,-effects,-offset
		//
		// Becomes:
		//
		//   grunt build:*:*:+ajax:-dimensions:-effects:-offset

		grunt.log.writeln( "Creating custom build...\n" );

		grunt.util.spawn({
			grunt: true,
			args: [ "build:*:*:" + modules, "pre-uglify", "uglify", "dist" ]
		}, function( err, result ) {
			if ( err ) {
				grunt.verbose.error();
				done( err );
				return;
			}

			grunt.log.writeln( result.stdout.replace("Done, without errors.", "") );

			done();
		});
	});
};
